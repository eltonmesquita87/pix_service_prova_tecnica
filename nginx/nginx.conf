# =======================================================================================
# NGINX Configuration - Load Balancer para Pix Service
# =======================================================================================
# Configuração otimizada para:
# - Load balancing round-robin entre múltiplas réplicas
# - Health checks ativos
# - Timeouts ajustados para Spring Boot
# - Logs estruturados
# - Compressão gzip
# - Connection pooling
# =======================================================================================

user  nginx;
worker_processes  auto;  # Usa todos os cores disponíveis

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

# Configurações de eventos
events {
    worker_connections  2048;  # Máximo de conexões simultâneas por worker
    use epoll;                 # Método eficiente para Linux
    multi_accept on;           # Aceita múltiplas conexões de uma vez
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # =======================================================================================
    # Formato de Logs
    # =======================================================================================
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" '
                    'rt=$request_time uct="$upstream_connect_time" '
                    'uht="$upstream_header_time" urt="$upstream_response_time"';

    log_format json_combined escape=json
        '{'
        '"time_local":"$time_local",'
        '"remote_addr":"$remote_addr",'
        '"request":"$request",'
        '"status": "$status",'
        '"body_bytes_sent":"$body_bytes_sent",'
        '"request_time":"$request_time",'
        '"upstream_response_time":"$upstream_response_time",'
        '"upstream_addr":"$upstream_addr",'
        '"http_user_agent":"$http_user_agent"'
        '}';

    access_log  /var/log/nginx/access.log  json_combined;

    # =======================================================================================
    # Performance Settings
    # =======================================================================================
    sendfile        on;
    tcp_nopush      on;
    tcp_nodelay     on;
    keepalive_timeout  65;
    types_hash_max_size 2048;
    client_max_body_size 10M;

    # =======================================================================================
    # Gzip Compression
    # =======================================================================================
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript
               application/json application/javascript application/xml+rss
               application/rss+xml font/truetype font/opentype
               application/vnd.ms-fontobject image/svg+xml;
    gzip_disable "msie6";

    # =======================================================================================
    # Upstream - Pool de Réplicas do Pix Service
    # =======================================================================================
    upstream pix_service_backend {
        # Estratégia de balanceamento: round-robin (padrão)
        # Alternativas: least_conn, ip_hash, hash $request_uri consistent

        # Health check passivo (NGINX Plus tem ativo)
        # Marca servidor como down após 2 falhas em 30s
        server pix-service:8080 max_fails=2 fail_timeout=30s;

        # NOTA: Docker Compose com deploy.replicas automaticamente
        # registra múltiplas instâncias no DNS pix-service.
        # NGINX faz round-robin entre todos os IPs resolvidos.

        # Keepalive connections para melhor performance
        keepalive 32;
        keepalive_requests 100;
        keepalive_timeout 60s;
    }

    # Upstream separado para Actuator/Metrics (porta 8081)
    upstream pix_service_actuator {
        server pix-service:8081 max_fails=2 fail_timeout=30s;
        keepalive 16;
    }

    # =======================================================================================
    # Server Block - Aplicação (porta 80 -> 8080 backends)
    # =======================================================================================
    server {
        listen 80;
        server_name _;

        # Timeout configurations (ajustado para Spring Boot)
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        send_timeout 60s;

        # =======================================================================================
        # Health Check Endpoint (NGINX próprio)
        # =======================================================================================
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }

        # =======================================================================================
        # Actuator Health (agregado de todas as réplicas)
        # =======================================================================================
        location /actuator/health {
            proxy_pass http://pix_service_actuator/actuator/health;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Cache health checks por 5 segundos
            proxy_cache_valid 200 5s;
        }

        # =======================================================================================
        # Aplicação Principal
        # =======================================================================================
        location / {
            # Proxy pass para o upstream
            proxy_pass http://pix_service_backend;

            # HTTP version e headers
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host $server_name;

            # Identificar réplica que respondeu (para debug)
            add_header X-Upstream-Addr $upstream_addr always;
            add_header X-Response-Time $request_time always;

            # Buffering
            proxy_buffering on;
            proxy_buffer_size 4k;
            proxy_buffers 8 4k;
            proxy_busy_buffers_size 8k;

            # Retry configuration
            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503;
            proxy_next_upstream_tries 2;
            proxy_next_upstream_timeout 30s;
        }
    }

    # =======================================================================================
    # Server Block - Actuator/Metrics (porta 8081)
    # =======================================================================================
    server {
        listen 8081;
        server_name _;

        # Apenas métricas, sem logs de acesso
        access_log off;

        location /actuator {
            proxy_pass http://pix_service_actuator;
            proxy_http_version 1.1;
            proxy_set_header Connection "";
            proxy_set_header Host $host;

            # Adicionar header identificando réplica
            add_header X-Upstream-Addr $upstream_addr always;
        }

        # Health check simplificado
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }
}

# =======================================================================================
# NOTAS DE CONFIGURAÇÃO
# =======================================================================================
# 1. Docker Compose DNS Resolution:
#    - Docker Compose com deploy.replicas=2 faz com que o DNS "pix-service"
#      resolva para múltiplos IPs (um por réplica).
#    - NGINX automaticamente balanceia entre todos os IPs resolvidos.
#
# 2. Health Checks:
#    - NGINX Open Source não tem health checks ativos (apenas passivo).
#    - Usa max_fails e fail_timeout para detectar backends down.
#    - Para health checks ativos, considere NGINX Plus ou HAProxy.
#
# 3. Session Affinity (Sticky Sessions):
#    - Se necessário, usar: ip_hash ou hash $cookie_JSESSIONID consistent;
#    - Não recomendado para APIs stateless como Pix Service.
#
# 4. Logs:
#    - access.log em formato JSON para parsing por ferramentas (Elastic, Splunk).
#    - Inclui upstream_response_time para monitorar performance de cada réplica.
#
# 5. Performance:
#    - Keepalive connections reduzem overhead de TCP handshake.
#    - Gzip compressão reduz tamanho de resposta JSON.
#    - Buffering otimizado para payloads típicos de Spring Boot.
# =======================================================================================
